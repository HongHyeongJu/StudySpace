<br>

# 해시테이블
[쉽게 배우는 자료구조 with 자바]


---

### 해시테이블
#### 해시테이블
- 자료를 검색, 삽입, 삭제하는 데 평균 O(1) 시간이 가능하게하여 극단적 효율에 다다른 자료구조
- 키 자신의 값에 따라 자리가 정해짐
- **해시테이블**이란 키가 저장된 자리를 키의 '값'으로 결정하는 자료구조
- 남과 비교하지 않고 자기 자신의 값에 의해 자리를 결정함
- 해시함수는 임의의 키값을 입력으로 받아 주소 중 한 자리를 리턴함. 이 리턴 값이 바로 해당 키를 저장하는 자리
- **충돌** : 해시값이 가리키는 자리에 이미 값이 들어있어서 넣을 수 없는 것
- **적재율** : 해시 테이블에 원소가 차 있는 비율. 해시테이블의 성능에 매우 중요한 영향을 미침.
- 해시테이블의 크기가 m이고, 저장된 키의 총 수가 n이면 적재율은 n/m이다.
- 적재율이 높을 수록 충돌 확률이 높아져 해시 테이블의 성능이 나빠진다.

<br>

#### 해시테이블
- 책에서 다루는 2가지 스타일의 해시테이블 구현 방식
- 해시테이블의 객체는 같은 모양
- 키를 저장하는 배열 table[]의 타입이 다르고, 운용 방식이 다름

<br>

---
<br>
<br>

### 해시함수
#### 나누기 방법
- 해시함수의 모양 **h(x)=x%m**
- **m** 해시테이블의 크기
- **%** 나머지 연산
- 해시테이블에 있는 m개의 자리가 0부터 m-1의 주소값을 가지므로 m으로 나눈 나머지 연산을 사용하는 것이 매우 자연스러움
- 해시테이블 크기 m은 2의 멱수에 가깝지 않은 소수를 택하는 것이 좋음 (멱수 : 거듭제곱으로 된 수)
- 만일 m=2^p라면 입력 키의 하위 p비트에 의해 해시값이 결정되므로 해시값 분산시키기에 이상적이지 않음
- 해시값은 입력 키의 모든 비트를 이용하는 것이 확률적으로 좋은 분포를 갖도록 하는데 유리함


<br>

#### 곱하기 방법
- 먼저 입력 값을 0과 1사이의 소수로 대응 시킴 -> 해시 테이블 크기 m을 곱하여 0부터 m-1 사이로 팽창시킴
- 해시함수의 특성을 결정 짓는 0<A<1 범위의 상수A를 미리 준비해둬야 함
- 임의의 키 x 확정.
- x에 A를 곱한다음 소수부만 취한다
- 방금 취한 소수부에 m을 곱하여 그 정수부를 취한다.
- **h(x)=[m(xA%1)]**
- 해시테이블의 크기 m을 아무렇게나 잡아도 상관 없고, 오히려 컴퓨터 이진수 환경에 맞게 m=2^p로 잡는 것이 자연스러움
- 메모리 할당 시 흔히 2의 멱수 크기로 할당하기 때문에
- 대신 상수A를 어떻게 잡느냐에 따라 해시값의 분포가 영향을 받음

<br>

#### 나누기 방법 vs 곱하기 방법
- 해시 함수 모양의 차이
- 해시테이블 크기의 조건
- 주소값의 결정 방법


<br>

---
<br>
<br>

### 충돌해결
- **충돌** : 동일한 주소에 2개 이상의 키가 해싱되는 상황
- **체이닝** : 충돌을 일으킨 키들을 연결 리스트로 관리하는 방법. 해시 테이블의 각 주소가 리스트의 헤더 역할, 여기에 해당 주소로 들어오는 키들이 연결 리스트에 매달림
- **개방 주소 방법** : 추가 공간 없이 어떻게든 해시 테이블 안에서 충돌을 해결하는 방법. 키가 원래 들어갈 자리가 아니어도 다른 자리를 찾아 들어감

<br>

#### 체이닝
- 같은 주소로 해싱되는 키를 모두 하나의 연결 리스트로 매달아서 관리함
- 해시 테이블의 크기가 m이면 최대 m개의 연결 리스트가 존재할 수 있음
- 연결리스트에 키 삽입 시 리스트의 맨 앖에 삽입하는 것이 좋음
- 키를 검색할 때는 해당 연결 리스트의 키들이 차례로 지나가며 찾음
- 체이닝은 적재율이 1을 넘어도 사용할 수 있다는 장점

<br>

#### 개방 주소 방법
- 체이닝과 달리 추가 공간 사용하지 않음
- 충돌이 일어나더라도 어떻게든 주어진 테이블 공간에서 해결함
- 모든 키가 반드시 자신의 해시값과 일치하는 주소에 저장된다는 보장 없음
- 해시함수 계산 -> 계산된 주소에 다른 키가 없으면 그 자리에 넣음 -> 다른 키가 있으면 정해진 규칙에 의해 다음 차리를 찾고 빈자리가 나올때까지 반복 (순차적인 해시함수)
- 충돌이 일어난 경우 다음 해시 함수를 계속 계산해서 다른 자리를 확인함
- 주어진 공간만 사용할 수 있으므로 적재율이 1을 넘을 수 없음
- 적재율이 어느 정도 이상 높아지면 효율이 급격히 떨어지기 때문에 적당한 임계점을 설정하고, 그 임계점을 넘으로 테이블의 크기를 2배로 키우는 것이 일반적
- 테이블 크기가 바뀌면 해시 함수가 바뀌므로 모든 키는 다시 해싱함
- **주의해야할 경우** : 키를 삭제했을 때
- 중간에 있는 주소의 키가 삭제되면 이후 거쳐갈 수 없기 때문에 키를 삭제할 때 원래는 키가 있었던 자리였음을 표시해주어야함.
- 이후 삽입과정에서 상수 DELETED를 만나면 그 자리에 키를 넣으면서 DELETED가 없어지기 때문에 우려할 필요 없음

#### 개방 주소 방법의 충돌 해결법 3가지
- 선형 탐색, 이차원 탐색, 더블 해싱
- **선형 탐색**
  - 충돌이 일어난 바로 뒷자리를 보는 것(i에 관한 일차 함수의 보폭으로 동일하게 점프)
  - 테이블의 경계를 넘어갈 경우에는 맨 앞으로 감
  - 특정 영역에 키가 몰릴 때는 치명적으로 성능이 떨어짐 = 일차군집
- **이차원 탐색**
  - 바로 뒷자리를 보면서 + 보폭을 이차 함수에 의해 넓혀가면서 본다
  - 1차 군입 영역을 이차원 탐색 방법을 이용해서 벗어남
  - 여러 개의 키가 동일한 초기 해시 함수값을 가지면 모두 같은 순서로 탐색하게 되므로 비효율을 피할 수 없음
  - 보폭은 점점 넓어지지만 최초의 해시값이 같은 키들은 이득을 못봄
- **더블 해싱**
  - 2개의 서로 다른 함수를 이용함
  - 충돌이 생겨 ㄷ음에 볼 주소를 계산할 때 두번째 해시 함수값만큼 점프함
  - 두 키의 첫번째 해시값이 같더라도 두 번째 함수값이 같을 경우는 매우 희박하므로, 더로 다른 보폭으로 점프함
  - 2개의 해시 함수를 정할 때 권장하는 방법 : 소수m에 대하여 h(x)=x%m으로 잡고, m보다 조금 작은 소수 m'에 대해 f(x)=1+(x%m')로 잡기
  - 조심할 점은 두번째 해시 항수값 f(x)가 해시 테이블 크기 m과 서로 소인값이어야 함
<br>

#### 검색 시간
- **체이닝 방법 검색시간**
  - 적재율이 a일때, 탐색 횟수의 기대치는 a에 비래함
- **개방 주소 방법 검색시간**
  - 이론적으로는 체이닝이 더 좋지만 적재율이 높지 않을 때는 개방 주소 방법이 더 선호됨
  - 개방주소 방법은 자신이 해시되지 않은 주소에 저장될 수 있으므로 복잡해짐
  - 검색에 실패할 경우 탐색 횟수의 기대치는 1/1-a 이하.  0<=a<1=임
- 체이닝은 우선 각 연결리스트마다 헤드를 하나씩 두어야하고, 연결리스트를 만들기 위해 각 키마다 연결을 위한 공간이 필요함
- 적재율이 1/2이하로 높지 않을 때는 개방 주소 방법이 더 선호됨
- 개방 주소 방법은 적재율이 절대로 1을 넘지 못하지만, 체이닝은 제한이 없음
- 어떤 경우든 적재율이 높으면 해싱의 효율이 떨어지기 때문에 적절하게 낮은 적재율을 유지할 필요가 있음

<br>
<br>