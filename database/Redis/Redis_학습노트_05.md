## 유데미 Redis : 개발자를 위한 Redis 완벽 가이드
### ch.18 - 동시성 문제 이해하고 해결하기

<br>
<br>


### 동시성 문제 다시보기
* 입찰 상황에서 $10로 변경하고 나면 key변경으로 인해서 $15 입찰 요청의 트랜잭션이 취소됨
* 이런 상황에 대한 솔루션
  * 유효헌 트랜잭션이 실패했을 경우 재시도 매커니즘을 구현할 수 있게 해주기
  * 블록 전체가 WATCH 오류로 인해 실패해도 다시 실행을 시도할 수 있음
    * 문제점
      * 이 접근법을 쉽게 확장할 수 없음. WATCH 명령어를 쓰면 Redis 서버가 느려짐
      * 이걸 재시도하면 정보를 받기 위한 추가적인 요청으로 인해 Redis 서버에 추가적인 부하를 가하게됨
* WATCH는 너무 많은 요청이 유입되면 트랜잭션이 너무 많이 실패하게됨


<br>


### 느슨한 스크립트를 이용하는 약간 더 우수한 동시성 처리 방법
* Redis 안에서 어떤 값을 업데이트하려는, 혹은 읽기 작업을 하고 쓰기 작업을 하려는 두 개의 프로세스가 있을 때 오직 한 프로세스만 어떤 시점에 어떤 값을 수정할 수 있도록 하기
* lock이라는 기법을 이용하면 됨
  * 프로세스 1이나 프로세스 2가 이 해시에 연계된 무언가를 업데이트하려고 하면
  * 먼저 Redis에서 아주 특수한 키를 설정하기(별도의 키, 키 이름은 상관 없음)
  * 같은 키 이름으로 무작위 단어를 저장하도록 함 + NX 옵션 붙여서!
    * 먼저 도착한 요청이 SET 명령어 전송 - > HASH에 작업 가능함 (우리가 구체적으로 막으려고 하는 건, 다른 프로세스가 읽기를 하고 이어서 쓰기 작업을 하는 것)
    * 두번째로 도착한 요청은 SET 명령에 실패함
    * 어떤 시점에서 프로세스 1이 모든 작업(읽기/쓰기)을 마무리 ->  lock:item:a1에 저장된 키를 삭제
    * 프로세스 2가 SET 명령을 전송하고 성공하게 되고, 프로세스 2가 item:a1에 대한 배타적인 접근권을 갖게 됨!
* lock이라는 기법을 이용해서, 오직 한 프로세스만 어떤 시점에 어떤 주어진 키에 관련된 읽기와 쓰기 작업 또는 책임을 갖도록 할 수 있음


<br>



### Redlock의 단순화 버전 예시
* Redlock은 운영 등급의 동시성 잠금 알고리즘
  * 실무에서 사용함
  * 구축할 필요 없고 대신 Redlock 알고리즘을 자동으로 구현해주는 유명한 라이브러리 사용하기
  * https://redis.io/docs/manual/patterns/distributed-locks/
    * Redisson (Java implementation).
    * https://github.com/redisson/redisson




<br>


### Redlock의 단순화 버전 함수 구현
* 단순화 버전
  * 인수1: 키(잠그려는 대상)
  * 인수2: 콜백함수(잠금에 성공한 뒤에 실행할 모든 논리 구현하기. 항목 fetching -> 검증 수행 -> 데이터 작업)
    * 재시도 간격
    * 재시도 횟수
    * 해시로 토큰 만들기
    * 반복문으로 시도
* 필기
* 필기
* 필기


<br>


### withLock 함수 사용하기
* 필기
* 필기
* 필기
* 필기
* 필기


<br>


### 자동으로 lock 만료 시키기
* 필기
* 필기
* 필기
* 필기
* 필기



<br>


### lock에 관한 또 다른 문제
* 필기
* 필기
* 필기
* 필기
* 필기



<br>


### 우발적인 lock 해제 문제 해결하기
* 필기
* 필기
* 필기
* 필기
* 필기



<br>


### lock 해제 스크립트 추가하기
* 필기
* 필기
* 필기
* 필기
* 필기



<br>


### 마지막으로 남은 문제
* 필기
* 필기
* 필기
* 필기
* 필기



<br>


### 만료 신호 제공하기
* 필기
* 필기
* 필기
* 필기
* 필기



<br>


### 만료에 대한 또 다른 해법 Redis
* 필기
* 필기
* 필기
* 필기
* 필기

