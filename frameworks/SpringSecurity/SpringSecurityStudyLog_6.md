## JOT, JWT
* 기본 인증의 단점
  * 기본 인증 헤더에 만료 기한이 없음
  * 사용자에 관련되 세부 정보가 전혀 없음, 권한 여부도 알 수 없음
  * 기본 인증 헤더는 쉽게 디코딩 됨
* 사용자 지정 토큰 시스템
  * 보안 결함이 있을 수 있음
  * 서비스 제공자과 서비스 소비자가 사용자 지정 토큰 시스템을 이해할 수 있어야함
* JWT(Json Web Token) (JOT라고 부름)
  * 두 당사자들 간의 안전한 클레임 표시를 위한 '공개 산업 표준'
  * 사용자 세부정보과 인증을 모두 담을 수 있음
    * Header :
      * Type 토큰의 타입
      * Hashing Algorithm 
    * Payload :
      * [표준 속성]
      * iss 토큰의 발행자 
      * sub 토큰의 주제 
      * aud 사용 대상
      * exp 토큰의 만료 날짜
      * iat 토큰이 발행된 시간
      * [사용자 지정 속성]
      * 사용자 지정 속성 
    * Signature
      * Base64로 인코딩된 헤더의 값, Base64로 인코딩된 페이로드의 값
      * Includes a Secret
  * 요약하자면 Header + Payload + Signature

    <br>
    <br>

## jwt.io
* jwt.io에서 JWT를 디코드, 검증, 생성할 수 있음
* Header + Payload + Signature
* JWT에서 키를 이용하여 암호화와 복호화 할 수 있음
* 암호화 2가지 타입
  * 대칭 키 암호화
    * 동일한 키를 이용해서 암호화와 복호화를 함
    * 암호화 알고리즘과 복호화 알고리즘이 모두 동일한 데이터 암호화 키를 사용하는 것
    * (중요1) 올바른 알고리즘을 선택하기
    * (중요2) 데이터 암호화 키를 안전하게 보관하기(잃어버리기X 타인의 접근X)
    * (중요3) 암호화 키를 공유하는 방법
  * 비대칭 키 암호화
    * 대칭 키 암호화의 대안
    * 공개 키와 비밀 키 : 공개 키 암호화 기법
      * 공개 키를 이용해서 데이터를 암호화, 누구에게나 공유
      * 비밀 키를 이용해서 위의 데이터를 복호화, 당사자가 보관, 개인키
    * 의문점, 누군가 공개 키를 이용해서 비밀키를 알아낼 수 있지 않을까?
      * NO! 공개 키와 비밀 키를 생성하는 알고리즘은 매우 강력함

        

    <br>
    <br>

## JWT의 흐름
#### [1] JWT 생성하기
* 다양한 세부정보 인코딩하기
  * 사용자 자격증명 (사용자 이름, 사용자 패스워드)
  * 페이로드 (사용자 데이터 = 자격증명을 기초로 받음)
  * RSK key pair
* JWT를 생성하기 위한 JWT 리소스를 생성
#### [2] 요청 헤더의 일부로 JWT를 전송하기
* 인증 헤더의 일부로 Bearer 토큰 형태로 전송함
* Authorization: Bearer ${JWT_TOKEN}
* (리소스에 액세스하기 위해 그걸 요청 헤더의 일부로서 전송하는 단계)
#### [3] JWT가 서버에서 확인됨
* 서버는 JWT를 받고 디코딩 함
* 디코딩을 위해 RSA key pair이 필요함 (공개키, Public Key)


    <br>
    <br>

## JWT 보안 설정
* Spring Boot의 OAuth2 리소스 서버를 이용해서 JWT 설정을 적용함
* 필요한 단계 
  * 키 쌍 만들기
  * RSA 키 객체 만들기
  * JWKSource, 즉 JSON Web Key 소스 만들기
  * 디코딩 설정하기 (RSA 공개키 이용)
  * 인코딩 설정하기 (JWKSource 이용)
````java

````



