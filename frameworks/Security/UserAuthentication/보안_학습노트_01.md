### 100일 코딩 챌린지 - Web Development 부트캠프 [섹션30] 
웹사이트 보안
* 위험한 공격 패턴의 개념
* 공격의 실행 방법
* 공격에 방어하는 방법
* 웹페이지의 취약여부 알아보기
* 공격과 관련하여 사용자의 입력을 피하고 삭제하는 방법(라이브러리)

<br>

#### 웹사이트가 취약할 수 있는 위험한 공격 패턴
* CSRF 공격
* XSS 공격
* SQL 주입 공격

#### 정리 순서
* 공격 패턴 작동 방식
* 웹 사이트 강화 방법
* 공격패턴으로부터 보호하는 방법

<br>


## 🚨 CSRF 공격
* 사이트간 요청 위조
* 수행해서는 안되는 작업을 유발하는 요청을 서버 백엔드로 보내는 것 
* 의도하지 않은 세션을 이용함
* 우리의 웹사이트와 유사하게 만들고 일반 사용자의 로그인을 유도함(스팸이메일 등을 통해서)

### ⚔️ 공격 방법
* 공격 패턴
* 숨겨진 입력 필드에 자체 값으로 준비된 양식을 가지고 올바른 웹사이트로 전송되는 악성 웹사이트. 쿠키가 해당 발신 요청에 첨부됨
  * 공식 사이트의 HRML 스타일을 훔쳐서 위조사이트를 만듦
  * 해당 사이트의 로그인 정보로 로그인하게 한 뒤
  * 송금화면 등에서 받는 사람, 금액을 방문자가 입력한 값이 아닌 조작한 input 을 조작함
  * 공격자가 가짜 사이트에서 편집한 양식이 제출되는 URL이 공식 사이트의 주소(올바른 URL주소)일 경우 전송이 가능함
  * 요청이 다른 사이트에서 전송되더라도, 요청의 대상이기에 대상 URL이 중요함
  * 그것이 정확한 URL이라면 브라우저는 쿠키에 첨부하게됨
* 해당 요청이 우리의 악성 사이트에서 전송된 경우에도 쿠키가 해당 발신 요청에 첨부됨

### ⚠️ 반 효과적인 방법
* [samesite] 쿠키
* 최신 브라우저에는 세임사이트 쿠키라는 기능이 있음
  * 명시적으로 구성되지 않은 경우 브라우저가 특정 기본값을 가정하는 서버 측에서 설정할 수 있는 쿠키 구성
  * 쿠키는 다른 사이트에서 수신되는 요청에 첨부될 수 있음 
  * 그러나 인터넷 익스플로러 사용자는 완전히 제외됨
    * 서버측 코드에서 명시적으로 설정하도록 쿠키를 구성하더라도 데이터가 이 세임사이트 설정을 전혀 지원하지 않기 때문
    * 여기서 {SameSite}를 설정하고 {lax}, {none}, {strict}를 설정할 수 있음
    * {lax}로 설정하면 지원되는 모든 브라우저에 관해 {lax}를 활성화함 (심지어 기본값으로 사용하지 않는 브라우저도 마찬가지)
    * {lax}는 쿠키가 다른 사이트에서 수신되는 요청에 첨부될 수 있다는 것
      * 단, 메인 사이트에서 해당 사이트를 방문한 경우에만 가능
*  이메일의 일부 링크를 클릭하면 보내는 요청에 쿠키가 첨부되지 않음
  * 불법 사이트 입력조작 공격 패턴이 작동하지 않음
  * 하지만 몇 가지 제한 사항과 염두에 두어야 할 사항이 있음
  * 하나는 로컬 호스트에 있는 경우 비활성화됨. 개발자 테스트 상황이라 사실 상관없음
* 따라서 이 세임사이트 쿠키 설정은 절대적으로 있으면 좋지만 (추가 보호 기능을 추가하지만) 그 자체로는 CSRF 공격으로부터 완전히 보호하기에는 충분치 않음



### 🛡️ 효과적인 방어 방법
* CSRF 토큰 생성
  * 서버 측에서 생성되는 무작위로 보이는 문자열 값인 토큰
  * 서버에서만 알 수 있고 수명 주기가 짧음
  * 토큰들은 하나의 요청 응답 주기 동안에만 존재
  * 그리고 서버가 해당 토큰을 생성했기 때문에 서버에 알려진 것
  * 방법
    * 해당 토큰을 사용해서 해당 문자열을 서버에서 렌더링하는 템플릿에 주입 
    * ex) 숨겨진 입력 필드에 주입
    * 그런 다음 수신되는 요청에 관해 서버는 그러한 유효한 토큰이 해당 요청의 일부인지 확인
    * 서버만이 이러한 토큰을 알고 있기 때문에, 그 이후에는 한 번의 수신 요청에 대해서만 유효하기 때문에, 그리고 공식 템플릿에만 존재하기 때문에 
    * 소유한 해당 서버가 렌더링한 공식페이지, 공격 서버, 가짜 서버는 해당 토큰을 알 수 없음. 추측할 수도 없음. 다른 서버에서 생성할 수도 없음
    * 서버만이 올바른 토큰을 알고 있으며 도난당할 수도 없음
    * 따라서 유효한 CSRF 토큰이 없는 요청은 차단됨



<br>

## 🚨 XSS 공격
* 크로스 사이트 스크립팅
* 악성 자바스크립트 코드를 웹사이트 콘텐츠에 주입하는 것
* 일반적인 웹페이지 로딩 시 이제 표시되는 콘텐츠는 서버, 백엔드는 템플릿을 렌더링함
* 따라서 브라우저의 방문자, 사용자에게 표시되는 HTML 코드를 생성하고 그 컨텐츠가 렌더링되고 생성된 HTML 파일의 컨텐츠는 일부 데이터 소스에서 가져올 가능성이 매우 높음

### ⚔️ 공격 방법
* 생성된 페이지의 일부가 될 컨텐츠에 악의적인 자바스크립트 코드를 모래 넣으려고 시도함
  * 렌더링된 HTML 페이지는 악의적인 브라우저 측 자바스크립트 코드를 포함하므로 해당 페이지가 방문자의 브라우저에 로드될 때 실행됨
  * 브라우저의 모든 방문자에 대해 실행될 수있음
  * 브라우저 측 자바스크립트는 매우 강력함
    * 예를 들어 이것을 사용해서 Ajax 요청을 보낸 다음 모든 종류의 요청을 보내 다시 송금을 한다든가 뭐 이와 유사한 것을 보낼 수 있음
* 인증의 유무에 관계없이 XSS 취약점이 있을 수 있음
* 사용자 생성 컨텐츠를 출력할 때마다 이 공격에 취약해짐
  * 사용자가 게시물, 댓글 뉴스 등 무엇이든 제출할 때마다 해당 컴텐츠를 출력하는 페이지의 일부가 있다면 잠재적인 취약점을 갖게 되는 것
* ex) textarea 태그 사이에 ```<script> alert('해킹'); </script>```  넣기 등
* 일부 유효한 자바스크립트 코드를 작성하면 동작함
* Ajax요청을 보내거나  세션을 사용할 수도 있음
* 쿠키는 Ajax요청과 함께 전송되기 때문에 실제로 CSRF의 보호를 받지 않음


### 🛡️ 효과적인 방어 방법
* 컨텐츠를 이스케이프 하기, 이스케이프 처리되지 않은 사용자 입력을 출력하려는 경우 삭제하기
  * 컨텐츠 이스케이핑
    * 단순히 HTML 특정 기능이 비활성화되거나, 전체 HTML 블록이 실제로 HTML 대신 원시 텍스트로 처리되는것
    * 모든 HTML 태그가 있을 수 있지만 브라우저에서 구문 분석하도록 브라우저에 전달하는 대신 일반 텍스트로 출력하고 브라우저에서 구문 분석하지 못하도록 함
    * 이전에 입력한 스크립트 태그가 브라우저에서 실행되지 않고 화면에 일반 텍스트로 출력됨
    * 사용자 컨텐츠에 EJS 이용하기
    * EJS 태그를 등호와 함께 사용하면 출력될 컨텐츠가 이스케이프 처리되고 결국에는 일반 텍스트로 처리됨
    * (HTML이 아닌 일반 텍스트로 브라우저에 구문 분석됨)
  * 사용자 입력을 삭제
    * 두 방법을 모두 수행할 필요는 없지만 일반적으로 삭제처리보다는 이스테이프를 우선적으로 처리해야함
    * 삭제에 관해서도 알아둘 상황
      * 이스케이프 처리 할 수 없지만 일부 원시 HTML 컨텐츠를 출력해야 하고
      * 이를 HTML로 구문 분석해야 하는 시나리오가 있는 경우
      * 출력하기 전에 최소한 삭제하기를 고려할 수 있음
    * Node.js의 경우 [express-validator] 패키지 를 이용할 수 있음
    * 수신하는 {post} 라우트 페이지에 출력할 계획인 사용자 생성 컨텐츠를 수신하는 경우, 실제로 함수 호출로 이를 래핑할 수 있음 
* 이스케이프를 수행하고 + 삭제된 버전을 일반 텍스트로 출력하면 못생긴 {lt} 및 {gt} 자리표시자가 출력됨
* 그렇기 때문에 일반적으로 두 가지를 모두 수행해서는 안됨
* 삭제 및 이스케이프를 동시에 처리하면 안됨!!
* 대신 둘 중 하나를 수행해야 하는데 일반적으로 이스케이프 처리가 선호됨
* 이스케이프 처리되지 않은 컨텐츠를 출력하려는 경우 먼저 정리해서 삭제해야 함


<br>

## 🚨 SQL 인젝션 공격
* 사용자 생성 컨텐츠에는 SQL 쿼리의 일부로 실행될 수 있는일부 악성 부분이 포함될 수 있음


### ⚔️ 공격 방법
* 공격이 이동하는 검색 작동 방식
  * {GET} 요청과 함게 해당 양식의 모든 양식 입력이 URL에 쿼리 매개변수로 추가됨
  * 쿼리 매개변수에는 작성자의 이름이 있고 여기서 {WHERE} 문에 추가합니다 그런 다음 {WEHRE} 문이 있는 경우 전체를 쿼리에 추가함
* 이 {WHERE} 절에 String 같은 값을 직접 주입한다는 것


### 🛡️ 효과적인 방어 방법
* SQL 주입 공격으로부터 보호하려면 쿼리에 사용할 수 있는 사용자 입력 값을 그대로 사용해서는 안됨
* 대신 이스케이프 처리하기
* 구체적인 값으로 대체되어야 하는 자리표시자를 표시하기 위해 물음표를 사용함
* 그러면 해당 값이 이스케이프 처리되고 SQL 주입으로부터 보호할 수 있음
* 쿼리당 하나의 명령문을 사용하는 기본값을 고수하는 것이 좋음 ({mutipleStatements: false!)















