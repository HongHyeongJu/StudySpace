# 유데미 Spring Security 6 초보에서 마스터 되기 최신강의! (JWT , OAUTH2 포함)
## ch.11 - Oauth2 와 OpenId

<br>

### Oauth2 가 해결할 수 있는 문제
* Oauth2 란
  * OAuth 2.0은 인터넷 사용자가 자신의 정보를 저장하고 있는 서비스(예: Facebook, Google 등)의 자원에 대한 접근 권한을
  * 제3자 애플리케이션에 부여할 수 있도록 하는 개방형 표준
* Oauth2 발명 전에는
  * 제3자 애플리케이션에 본인의 인증서를 공유해야 했음
  * 남용되거나 다른 목적으로 쓰일 위험이 있음
* Oauth2 가 해결해주는 문제
  * 제3자 애플리케이션에 인증서 옹유 없이, 임시적인 접근 토큰을 부여할 수 있어짐(제한된 접근)
* Oauth2는 항상 별개의 인증 서버를 유지해야함
  * 이 서버에는 인증과 권한 로직이 존재함
  * 공통 승인 서버를 두고 있음(승인과 권한 관리)

<br>


### Oauth2 란?
* OAuth 2.0 framework
  * OAuth : Open Authorization
  * OAuth 2.0 는 단순한 사양임
  * 웹 애플리케이션 내에서 승인이나 허가를 받을 때 따라야 하는 적정한 기준을 정의하고 있는 것
  * 제품X, 서버X, 실행 구조물X, 단순한 사양 기준 규격O
* 한 애플리케이션이 다른 애플리케이션 내부에 있는 사용자의 데이터에 접속할 권한을 주는 것
* 제한된 권한을 허가해줌
  * 허가를 내리는 방법 : 액세스 토큰 발급
  * access 토큰
    * 제3의 웹 애플리케이션이 할 수 있는 행위
    * 어떤 권한을 가지는지
    * 어떤 허가를 받는지 결정 가능
* OAuth 2.0 구조물의 장점
  * 여러 상황에 다양하게 사용할 수 있는 Grant Types가 존재함
  * Grant Type(인증 부여 방식) 
    * OAuth 2.0 프로토콜에서 클라이언트가 액세스 토큰을 얻기 위해 인증 서버에 제공해야 하는 데이터의 유형을 정의함
    * 엔드유저가 자원에 접근할 권한을 얻는 과정 명시하는 것
    * OAuth 2.0 스펙에서는 정의하는 인증 부여 방식
      * Authorization Code Grant
      * Implicit Grant (OAuth 2.1에서 제거 예정)
      * Resource Owner Password Credentials Grant (Password Grant)  (OAuth 2.1에서 제거 예정)
      * Client Credentials Grant
      * Device Code Grant (Apple TV나 Android TV 등에 사용하는 것)
      * Refresh Token Grant
  * Flows(흐름)
    * 인증 부여 방식을 구현하는 과정에서 발생하는 일련의 단계
    * 인증 부여 방식은 특정 흐름을 따름
    * 흐름은 클라이언트가 액세스 토큰을 얻기 위해 인증 서버와 어떻게 상호작용해야 하는지를 설명하는 것
    * OAuth 2.0을 사용하는 애플리케이션의 유형(웹, 모바일, 서버 간 등)과 사용자 인터페이스의 특성(브라우저 기반, 네이티브 앱 등)에 따라 달라짐
    * 흐름 
      * Authorization Code Flow : 인증 코드를 사용하여 액세스 토큰을 얻는 과정
      * Implicit Flow : 클라이언트 사이드 애플리케이션에 바로 액세스 토큰을 발급하는 과정(현재는 권장되지 않음)
      * PKCE (Proof Key for Code Exchange) : Authorization Code Flow의 보안을 강화한 흐름
      * Resource Owner Password Credentials Flow : 사용자의 로그인 정보를 직접 사용하여 액세스 토큰을 얻는 과정
      * Client Credentials Flow : 클라이언트 자격 증명만을 사용하여 액세스 토큰을 얻는 과정
      * Device Code Flow : 디바이스에서 사용자 인증을 진행하는 과정
* Grant Type와 Flows 구분하기
  * Grant Type : 액세스 토큰을 얻기 위한 근거를 제공
  * Flows : 그 방식을 실제로 구현하는 과정의 시퀀스. 인증 부여 방식을 실행하기 위한 실제 단계들을 포함함
* OAuth 2.0 or OAuth 2.1에 대한 최신 정보를 얻을 수 있는 곳
  * oauth.net/2
  * OAuth 2.1의 의도 : 중복되는 플로우 제거, 더 단순하고 깔끔하게 만들기 위한 것



<br>

### Oauth2 용어 및 전문용어
* [1]. 리소스 소유자(Resource Owner)
  * 일반적으로 사용자를 의미
  * 리소스 소유자는 자신의 데이터나 자원에 대한 접근 권한을 클라이언트에게 부여할 수 있는 권한을 가짐 
  * ex) 소셜 미디어 플랫폼에서 사용자는 자신의 프로필 정보나 사진 등을 제3자 애플리케이션과 공유할 수 있는 리소스 소유자
* [2]. 클라이언트(Client)
  * 사용자(리소스 소유자) 대신 자원에 접근을 요청하는 애플리케이션
  * 클라이언트는 웹 애플리케이션, 데스크탑 프로그램, 모바일 앱 등이 될 수 있음
  * 클라이언트는 리소스 소유자로부터 권한을 부여받아 승인 서버로부터 액세스 토큰을 얻고, 이 토큰을 사용하여 리소스 서버에 접근함
* [3]. 승인 서버(Authorization Server)
  * 클라이언트에게 액세스 토큰을 발급하는 역할
  * 승인 서버는 클라이언트의 요청을 검증하고, 리소스 소유자의 인증 및 권한 부여를 관리
  * 클라이언트가 리소스 소유자로부터 필요한 권한을 얻었다는 것을 확인한 후, 적절한 액세스 토큰을 클라이언트에게 발급
* [4]. 리소스 서버(Resource Server)
  * 리소스 소유자의 데이터나 자원을 호스팅하는 서버
  * 리소스 서버는 클라이언트가 제출한 액세스 토큰을 검증한 후, 요청된 자원에 대한 접근을 허용 
  * ex) 소셜 미디어 서비스에서 사용자의 프로필 정보, 사진, 게시물 등이 리소스 서버에 저장되고 관리됨
* [5].아이덴티티 제공자(Identity Provider, IdP)
  * 인증 과정에서 사용자의 신원을 확인하고, 이 정보를 바탕으로 서비스에 접근할 수 있도록 하는 역할을 함

<br>

* 추가 용어
  * 액세스 토큰(Access Token)
    * 클라이언트가 리소스 서버에 접근할 수 있도록 승인 서버에 의해 발급되는 토큰입니다. 
    * 액세스 토큰은 특정 리소스에 대한 접근 권한을 나타냅니다.
  * 리프레시 토큰(Refresh Token)
    * 액세스 토큰의 유효 기간이 만료되었을 때 새 액세스 토큰을 얻기 위해 사용되는 토큰입니다. 
    * 리프레시 토큰은 클라이언트가 사용자의 추가적인 인증 없이 액세스 토큰을 갱신할 수 있도록 합니다.
  * 스코프(Scope)
    * 클라이언트가 요청한 접근 범위를 정의하는 문자열입니다. 
    * 스코프를 통해 클라이언트가 요청할 수 있는 리소스와 작업의 범위를 제한할 수 있습니다.
  * 권한 부여 코드(Authorization Code)
    * Authorization Code Grant 타입에서 사용되는 일회용 코드로, 클라이언트가 최종적으로 액세스 토큰을 얻기 위해 승인 서버로 전송합니다.
  * 리디렉션 URI(Redirection URI)
    * 클라이언트가 승인 요청을 시작할 때 승인 서버에 제공하는 URI로, 인증 과정이 성공적으로 완료된 후 사용자를 리디렉션할 위치를 지정합니다.


<br>


### Oauth2 플로우 예시
* 인증받으려는 아이덴티티 제공자(A)에 나의 애플리케이션을 등록
  * 클라이언트 ID 및 정보를 제공
* 사용자가 나의 애플리케이션에 회원가입 희망
  * A를 통해 로그인 하기 버튼을 누름
  * A 사이트의 로그인 페이지로 이동
* 리소스 소유자(사용자)가 본인의 정보로 로그인 페이지에 작성
  * 성공적인 인증 후에 A애플리케이션이 허가 페이지를 보여줌
  * 사용자에게 정보 공유 허락을 구함
  * 허가 요청에 응하면
* 승인 서버가 액세스 토큰과 리프레쉬 토큰을 클라이언트 애플리케이션에게 발급함
  * 발급 받은 토큰을 잘 보관하여서 A사이트에 요청을 보낼 때 승인 서버에서 받은 액세스 토큰을 넘겨줘야함
  * 리소스 서버는 Auth서버와 액세스 토큰을 관인하고 적절하면 데이터 보여줌

<br>


### Oauth2 내 리프레쉬 토큰 부여 유형의 흐름
* 리프레쉬 토큰 인증 유형 플로우에는 엔드유저가 관련되지 않음
* 클라이언트 애플리케이션은 특정 액세스 토큰의 유효기간 만료 소식을 접하자마자 엔드유저가 관련되지 않도록 함
* 그리고 처음 로그인 과정에 얻었던 리프레쉬 토큰을 활용함(대체로 리프레쉬 토큰은 유효기간이 존재하지 않음) -> 그러나 24시간 or 7일의 기간을 정하는 것이 좋음
* 리프레쉬 토큰 인증 유형 플로우
  * 클라이언트 애플리케이션이 리소스 서버에 접근 요청: 
    * 클라이언트 애플리케이션은 저장해둔 액세스 토큰을 사용하여 리소스 서버에 리소스 접근을 요청
  * 액세스 토큰 만료 확인:
    * 만약 액세스 토큰이 만료되었다면, 리소스 서버는 클라이언트에게 401 Unauthorized 응답을 보냄
    * 응답에는 일반적으로 액세스 토큰이 만료되었음을 나타내는 정보가 포함됨
  * 리프레시 토큰을 사용한 액세스 토큰 갱신:
    * 클라이언트 애플리케이션은 이전에 저장해 둔 리프레시 토큰을 사용하여 승인 서버에 새 액세스 토큰 발급을 요청
    * 승인 서버는 리프레시 토큰을 검증하고, 유효한 경우 새로운 액세스 토큰(그리고 필요에 따라 새로운 리프레시 토큰)을 클라이언트에게 발급
  * 새 액세스 토큰으로 리소스 접근 재시도:
    * 클라이언트는 새로 발급받은 액세스 토큰을 사용하여 리소스 서버에 다시 접근 요청
     * 이번에는 리소스 서버가 요청을 승인하고, 클라이언트는 원하는 리소스에 접근할 수 있음
* 로그인 과정에서 액세스 토큰과 리프레쉬 토큰을 받았다면 리소스 소유자 인증서를 계속해서 요구하지 않을 것

<br>


# 유데미 강의 오류로 이후 강의 재생 안됨. 일단 여기까지 적용하자
# 강의 시스템 수정!

<br>


### 리소스서버가 인증서버에서 발급한 토큰을 인증하는 방법
* 리소스 서버가 액세스 토큰을 점검하는 방법(접근법)
  * [1] 승인 서버와 리소스 서버간의 직접적인 API 교류하기
    * 리소스 서버는 액세스 토큰을 부여받을 때마다 승인 서버에 의해 노출된 API중 하나를 실행시킬 것임
    * 승인 서버가 접근 토큰의 적절함을 확인하면 리소스 서버는 클라이언트 애플리케이션에게 긍정적인 답변을 전송함
    * 단점 : 액세스 토큰 요청 발생시마다 리소스 서버가 승인 서버를 실행시켜야함
  * [2] 승인 서버, 리소스 서버가 공동 데이터베이스를 사용하기
    * 액세스 토큰이 클라이언트 애플리케이션으로부터 리소스 서버로 보내졌을 때, 리소스 서버는 데이터베이스에서 확인함
  * [3] 리소스 서버가 공개키로 액세스 토큰 확인하기
    * 전제 : 리소스 서버가 승인 서버로 연결되어야 함.(애플리케이션이 시작할 쯤 연결) (지속적인 연결 아님)
    * 연결 되었을 때 리소스 서버는 승인 서버로부터 공개 인증서를 받을 수 있음
    * 이 동일한 공개 인증서를 사용하여 인증서버로부터 발급되는 액세스 토큰을 뱓을 때마다 진위 여부 파악 가능함. 공개키를 이용한 것.
    * JWT 토큰의 시그니처와 유사한 것.


<br>


### OpenID connect란?
* OpenID 란 OAuth2.0 구조물 위에서 작동되는 프로토콜
  * 그러나 OAuth2.0 구조물을 사용하지도 않고, OAuth2.0 구조물 자체를 인지하지도 못하게함
* OAuth2.0 구조물은 HTTP 프로토콜 위에 만들어져 있음. 
  * 액세스 토큰의 도움을 얻어서 승인하는 역할을 함. 
  *  그리고 그 위에 작은층(프로토콜)이 만든 OpenID연결이 있음
* OpenID 연결은 권한과 인증을 모두 받을 수 있음

<br>











