## Docker의 작동방식 이해하기
<br>

### 그 전에, Docker가 왜 유명하고 인기가 많을까?
#### 1. 표준화된 애플리케이션 패키징을 제공
* 모든 유형의 애플리케이션에 대해 동일한 패키징을 포함하는 Docker 이미지를 생성할 수 있는 방법을 제공함
* 자바 애플리케이션, 파이썬 애플리케이션, Node.js 애플리케이션 등 무엇을 갖고 있든 같은 방식으로 패키지할 수 있음
* 최종 Docker 이미지의 포맷은 정확히 동일함
* 이를 실행하는 방식도 정확히 동일함

<br>

#### 2. 다중 플랫폼 지원
* Docker 런타임을 설치하기만 하면 로컬 머신, 데이터 센터, AWS, Azure, GCP 등의 클라우드를 비롯하여 원하는 곳이라면 어디든 실행할 수 있음


<br>

#### 3. 격리성
* 여러 컨테이너를 같은 머신에 실행하더라도 각 컨테이너는 다른 컨테이너로부터 격리됨

<br>
<br>

### 백그라운드에서 발생하는 일 살펴보기
```shell
$ docker container run -d -p 5000:5000 in28min/hello-world-nodejs:0.0.1.RELEASE
```
* 이 특정 명령어로 인해 백그라운드에서 일어나는 일
* Docker 이미지는 Docker 레지스트리에서 다운로드됨
* 사용되는 기본 Docker 레지스트리는 Docker 허브라고 함
  * hub.docker.com이 Docker 허브
  * 이미지 URL ex) https://hub.docker.com/r/in28min/hello-world-nodejs
  * 위의 주소를 가면  Docker 레지스트리 안에 저장소라는 것을 생성했음을 알 수 있음
  * 이 저장소 안에는 사용할 수 있는 여러 버전이 있음
  * Tags로 이동하면 n개의 태그 확인할 수 있음 ex) 0.0.1.RELEASE,   0.0.2.RELEASE
* 명령어 다시 살펴보기
  * in28min/hello-world-nodejs -> 저장소의 이름
  * :0.0.1.RELEASE -> 태그의 이름
  * 사용자는 Docker 레지스트리에서 이것을 다운로드하고, 이것을 로컬 머신에서 컨테이너로 실행하고 있는 것

<br>

### Docker 이미지란?
* 이미지는 정적인 바이트 집합
* 이 바이트는 Docker 레지스트리, 즉, Docker 허브 내에서 호스트되고, 컨테이너는 특정 이미지의 버전을 실행
* 현재 실행 중인 컨테이너가 있을 때 ```$ docker container ls```를 사용하면 알 수 있음
* 이대로 명령어를 실행하면 컨테이너를 나열해줌
* ```$ docker image ls```를 입력하면 로컬 머신에 있는 모든 이미지를 나열함
  * in28min/hello-world-nodejs도 여기 있는 이미지 중 하나
  * 정적인 바이트 집합입니다

<br>

* 특정 컨테이너 이미지에서 컨테이너를 생성하는 경우, 동적인 컨테이너가 됨
* Docker 이미지는 정적인 이미지이며, Docker 컨테이너는 실행 중인 이미지 버전
* 하나의 Docker 이미지에서 원하는 만큼 컨테이너를 생성할 수 있음
  * 애플리케이션의 인스턴스를 1,000개 실행할 수 있음
  * 같은 이미지에서 애플리케이션의 컨테이너를 1,000개 실행할 수도 있음

<br>

### 도커 레지스트리
* 이미지를 저장하는 서비스
* **저장소 이름**은 특정 애플리케이션, 특정 마이크로서비스에 연결됨
* **태그**는 특정 릴리스나 특정 애플리케이션의 버전, 마이크로서비스에 연결되어 있음

<br>

### -p 명령어
```shell
$ clear

$  docker container run -d -p 5000:5000 in28min/hello-world-nodejs:0.0.1.RELEASE
```
* ```-p hostport:containerPort```  호스트 포트와 컨테이너 포트를 매핑함
* 컨테이너 포트는 특정 컨테이너 내부에 있음
* 각 애플리케이션은 특정 포트의 컨테이너 내부에서 실행됨
* 컨테이너 포트를 취해서 특정 머신의 다른 포트에 노출할 수 있음
  * ```-p 5000:5000``` 이 경우, 이 애플리케이션을 포트 5000에 노출하고 있는 것
* ```$ docker container ls```를 실행하면  0.0.0.0:5000->5000/tcp으로 내부포트 5000이 외부포트 5000으로 매핑하는 것을 볼 수 있음
* 머신(브라우저)에서는 5000으로 애플리케이션에 액세스 할 수 있음
* 다른 포트(5001)에서 실행하려면 
* ```$  docker container run -d -p 5001:5000 in28min/hello-world-nodejs:0.0.1.RELEASE``` 5001로 변경
* (이미지가 로컬에 있기 때문에 매우 빠르게 실행됨)
  * Docker는 굉장히 영리해서 이미지가 이미 존재한다는 사실을 알고 있음
  * 다운로드할 필요가 없으니 그저 가져와서 실행하기만 하면 된다고 인식함

<br>

### 컨테이너 인스턴스 여러개 실행하기
* 컨테이너의 인스턴스를 2개 실행하기 가능
* 5000 또는 5002를 사용하려면 어느 포트를 사용할지 선택하기만 하면 됨
  * ```5000:5000``` , ```5002:5000``` 
  * 해당 포트가 사용되지 않았는지 확인한 다음 엔터
* 같은 컨테이너 이미지에 대해 이제 2개의 컨테이너가 실행할 수 있음
* ```$ docker container ls``` 를 입력하면 여러 인스턴스가 같은 컨테이너 이미지를 매핑함을 알 수 있음
* 브라우저로 이동해서 5001에서 5002로 포트를 변경해도 애플리케이션이 여전히 작동함을 볼 수 있음
* **-p를 사용**하면 내부 컨테이너 포트를 로컬 머신의 포트에 매핑할 수 있음
* 기본적으로 컨테이너를 실행하면 Docker는 자체 내부 네트워크를 사용하는데, 이것을 Bridge 네트워크라고 함
* 애플리케이션 사용자는 Bridge 네트워크에 액세스할 수 없기 때문에 포트를 노출함 (포트를 노출하는 이유)
  * "애플리케이션 사용자"는 도커 컨테이너 내부에서 실행되는 애플리케이션에 액세스하려는 모든 외부 주체를 의미
* 컨테이너 포트를 Bridge 네트워크에서 로컬 머신의 호스트 포트로 매핑하게되면, 사용자가 애플리케이션에 액세스할 수 있음


<br> 

### 도커에서 동일한 컨테이너 이미지를 여러 포트에 병행해서 실행시키는 이유
* 실제 운영 환경에서 예상되는 다양한 시나리오를 효과적으로 모의하고 테스트할 수 있음
* 로드 밸런싱 및 확장성 테스트
  * 여러 인스턴스를 실행하면 각 인스턴스에 대한 트래픽 분산을 시뮬레이션하고 로드 밸런싱 전략을 테스트할 수 있음
  * 실제 프로덕션 환경에서 고가용성과 확장성을 달성하기 위한 중요한 테스트 과정
* 다중 사용자 테스트 환경 구축
  * 다양한 사용자 또는 다양한 환경에서의 애플리케이션 작동을 테스트하기 위해, 
  * 각기 다른 설정이나 데이터를 가진 여러 컨테이너 인스턴스를 실행할 수 있음
* 개발 및 테스트 용이성
  * 개발자들이 동일한 애플리케이션의 다양한 버전을 동시에 실행하여 비교하거나
  * 다양한 개발 브랜치를 병렬로 테스트할 수 있음
* 포트 충돌 회피
  * 동일한 컨테이너 이미지를 서로 다른 포트에 바인딩함으로써 포트 충돌 문제를 회피할 수 있음
  * 특히 단일 호스트에서 여러 인스턴스를 실행할 때 중요함
* 멀티테넌시 환경 시뮬레이션
  * 실제 운영 환경에서 동일한 애플리케이션이 여러 고객 또는 사용자 그룹을 위해 독립적으로 실행될 수 있음 
  * 이를 통해 각 사용자 그룹에 대한 서비스 격리와 데이터 격리를 보장할 수 있음


<br> 

#### 궁금증 : 컨테이너 이미지 실행 시 외부 소비자 사용 가능?
* 도커 컨테이너는 AWS와 같은 클라우드 서비스 제공업체에서도 실행될 수 있음
* 도커 컨테이너가 AWS 또는 다른 클라우드 제공업체에서 실행될 때, 몇 가지 추가적인 네트워크 설정이 필요하긴함


<br>

### -d 명령어
* detached 모드를 가리킴
* -d를 지우고 기존의 명령어 실행
```shell
$ docker container run -p 5000:5000 in28min/hello-world-nodejs:0.0.1.RELEASE
```
* 컨테이너의 세 번째 인스턴스를 생성하려는 의도
* 나온 결과 : ```‘Ready on port 5000!(포트 5000에서 준비됨)’을 확인할 수 있지만 이 명령 프롬프트는 더 이상 사용할 수 없습니다```
* 이유는 이것은 이제 실행 중인 컨테이너와 직접 연결되었기 때문
* 새 터미널을 열고 ```$ docker container ls```를 입력하면 현재 3개의 컨테이너를 확인할 수 있음
* 이전 터미널에서 Ctrl+C나 Command+C를 사용하면 컨테이너가 즉시 종료됨
* detached 모드 없이 명령어를 실행하면 터미널은 컨테이너의 수명과 연결뙴
* 터미널의 연결을 끊으면 컨테이너는 자동으로 종료됨











